<!DOCTYPE html>
<html>
<head>
    <title>Portfolio Cost Tracking (v2)</title>
    <!--  (c) 2016 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Thu Aug 02 2018 16:22:43 GMT-0700 (PDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Aug 02 2018 16:22:43 GMT-0700 (PDT)";
        var BUILDER = "rajan08";
        var CHECKSUM = 272589648695;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: Ext.String.format("Build date/time: {0} ({1})",
                    APP_BUILD_DATE,
                    BUILDER)
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('CArABU.technicalservices.Exporter',{

    mixins: {
        observable: 'Ext.util.Observable'
    },
    constructor: function (config) {
        this.mixins.observable.constructor.call(this, config);
    },
    saveCSVToFile:function(csv,file_name,type_object){
        if (type_object === undefined){
            type_object = {type:'text/csv;charset=utf-8'};
        }
        this.saveAs(csv,file_name, type_object);
    },
    saveAs: function(textToWrite, fileName)
    {
        if (Ext.isIE9m){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for IE9 and below."});
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        }
        catch(e){
            window.BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder;
            if (window.BlobBuilder && e.name === 'TypeError'){
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for this browser."});
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p){
            window.navigator.msSaveOrOpenBlob(textFileAsBlob,fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url){
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink){
                downloadLink.download = fileNameToSaveAs;
            } else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome){
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        } else {
            Rally.ui.notify.Notifier.showError({message: "Export is not supported "});
        }

    },
    createObjectURL: function ( file ) {
        if ( window.webkitURL ) {
            return window.webkitURL.createObjectURL( file );
        } else if ( window.URL && window.URL.createObjectURL ) {
            return window.URL.createObjectURL( file );
        } else {
            return null;
        }
    },
    destroyClickedElement: function(event)
    {
        document.body.removeChild(event.target);
    },
    fetchExportData: function(rootModel, rootFilters, fetch, columns){
        var deferred = Ext.create('Deft.Deferred');
        var rootFetch = Ext.Array.merge(fetch, CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemFetch());
        var me = this;


        var loader = Ext.create('CArABU.technicalservices.RollupDataLoader',{
            portfolioItemTypes: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemTypes(),
            featureName: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getFeatureName(),
            listeners: {
                rollupdataloaded: function(portfolioHash, stories){
                    //onsole.log('rollupdataloaded', portfolioHash, stories);
                    var rollupData = Ext.create('CArABU.technicalservices.RollupCalculator', {
                        portfolioItemType: rootModel
                    });

                    rollupData.addRollupRecords(portfolioHash, stories);
                    //onsole.log('models updateded', portfolioHash, stories);
                    var exportData = me._getExportableRollupData(portfolioHash[rootModel.toLowerCase()],columns, rollupData);
                    columns = me._getAncestorTypeColumns(rootModel).concat(columns);

                    var csv = me._transformExportableRollupDataToDelimitedString(exportData, columns);
                    this.fireEvent('statusupdate', null);
                    deferred.resolve(csv);
                },
                loaderror: function(msg){
                    deferred.reject(msg);
                },
                statusupdate: function(status){
                    this.fireEvent('statusupdate', status);
                },
                scope: this
            }
        });
        loader.loadTree({model: rootModel, fetch: rootFetch, filters: rootFilters || []});

        return deferred;
    },
    _transformExportableRollupDataToDelimitedString: function(rollupData, columns){
        var csvArray = [],
            delimiter = ",",
            rowDelimiter = "\r\n",
            re = new RegExp(delimiter + '|\"|\r|\n','g');

        var column_keys = _.map(columns, function(c){ return c.costField || c.dataIndex; }),
            column_headers = _.pluck(columns, 'text');

        csvArray.push(column_headers.join(delimiter));

        Ext.Array.each(rollupData, function(obj){
            var data = [];
            Ext.Array.each(column_keys, function(key){
                var val = obj[key];
                if (val){
                    if (re.test(val)){ //enclose in double quotes if we have the delimiters
                        val = val.replace('"','\"\"');
                        val = Ext.String.format("\"{0}\"",val);

                    }
                }
                data.push(val);
            });
            csvArray.push(data.join(delimiter));
        });

        return csvArray.join(rowDelimiter);
    },
    /**
     * Returns an array of hash rollup data
     *
     * @param rootObjectIDs
     * @param columns - the data index of the columns that we want to export.
     * @param rollupData
     * @returns {Array}
     * @private
     */
    _getExportableRollupData: function(records, columns, rollupData){

        var exportData = [],
            me = this;


        _.each(records, function(r){
            var obj = rollupData.getRollupData(r);
            if (obj){
                var ancestors = {};
                var rec = obj.getExportRow(columns, ancestors);
                exportData.push(rec);
                me._addExportChildren(obj,exportData, columns, rollupData,ancestors);
            }
        }, this);
        return exportData;
    },
    _addExportChildren: function(obj, exportData, columns, rollupData,ancestors){
        var new_ancestors = Ext.clone(ancestors),
            me = this;
        new_ancestors[obj._type] = obj.FormattedID;

        var children = obj.children;
        if (children && children.length > 0){
            _.each(children, function(c){
                var row = c.getExportRow(columns, new_ancestors);
                exportData.push(row);
                me._addExportChildren(c, exportData, columns, rollupData, new_ancestors);
            }, this);
        }
        return;
    },
    _getAncestorTypeColumns: function(rootModel){
        var piTypes = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemTypeObjects(),
            piIdx = -1;

        Ext.Array.each(piTypes, function(piObj, idx){
            if (piObj.typePath.toLowerCase() === rootModel.toLowerCase()){
                piIdx = idx;
            }
        });

        var columns = [{
            dataIndex: 'hierarchicalrequirement',
            text: 'User Story'
        }];

        if (piIdx >= 0){
            columns = columns.concat(Ext.Array.map(piTypes.slice(0,piIdx+1), function(piObj) { return { dataIndex: piObj.typePath.toLowerCase(), text: piObj.name };} ));
            columns.push({
                dataIndex: 'type',
                text: 'Artifact Type'
            });
            columns.reverse();
        }
        return columns;
    },
    fetchWsapiRecords: function(model, query_filters, fetch_fields, context){
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: fetch_fields,
            filters: query_filters,
            context: context,
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    getCSVFromGrid:function(grid){

        var store = grid.getStore();

        var columns = grid.columns;
        var column_names = [];
        var headers = [];

        var csv = [];

        Ext.Array.each(columns,function(column){
            if (column.xtype != 'rallyrowactioncolumn' && (column.dataIndex)) {
                column_names.push(column.dataIndex);
                headers.push(column.csvText || column.text || column.dataIndex);
            }
        });

        csv.push('"' + headers.join('","') + '"');

        var mock_meta_data = {
            align: "right",
            classes: [],
            cellIndex: 9,
            column: null,
            columnIndex: 9,
            innerCls: undefined,
            recordIndex: 5,
            rowIndex: 5,
            style: "",
            tdAttr: "",
            tdCls: "x-grid-cell x-grid-td x-grid-cell-headerId-gridcolumn-1029 x-grid-cell-last x-unselectable",
            unselectableAttr: "unselectable='on'"
        }


        Ext.Array.each(store.getRange(), function(record){
            var node_values = [];
            Ext.Array.each(columns,function(column){
                if (column.xtype != 'rallyrowactioncolumn') {
                    if (column.dataIndex) {
                        var column_name = column.dataIndex;
                        var display_value = record.get(column_name);

                        if (!column._csvIgnoreRender && column.renderer) {
                            if (column.exportRenderer) {
                                display_value = column.exportRenderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                            } else {
                                display_value = column.renderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                            }
                        }
                        var val = "";
                        if (display_value){
                            if (Ext.isObject(display_value)){
                                display_value = display_value._refObjectName || display_value.Name || display_value.FormattedID;
                            }
                            if (isNaN(display_value)){
                                val = display_value.replace(/\"/g,'\"\"');
                            } else {
                                val = display_value;
                            }
                        }
                        val = Ext.String.format("\"{0}\"",val);
                        node_values.push(val);
                    }
                }
            },this);
            csv.push(node_values.join(','));
        });
        return csv.join("\r\n");
    }

});


Ext.define('CArABU.technicalservices.PortfolioCostApps.toolbox',{
    singleton: true,

    snapshotPrefPrefix: 'portfolioSnapshot-v1-',
    teamCostPrefPrefix: 'costAsOf-',
    getSnapshotPreferenceName: function(name){
        return Ext.String.format("{0}{1}",CArABU.technicalservices.PortfolioCostApps.toolbox.snapshotPrefPrefix,name);
    },
    getFriendlyNameFromSnapshot: function(snap){
        var name = snap.get('Name');
        return name.replace(CArABU.technicalservices.PortfolioCostApps.toolbox.snapshotPrefPrefix,'');
    },
    getSnapshotModelType: function(snap){
        var obj = Ext.JSON.decode(snap.get('Value'));
        return obj.type || null;
    },
    getSnapshotData: function(snap){
        var obj = Ext.JSON.decode(snap.get('Value'));
        return obj.data || {};
    },
    getEncodedSnapshotValueString: function(oidValueHash, type){
        var obj = {
            type: type,
            data: oidValueHash
        };
        return Ext.JSON.encode(obj);
    }
});


Ext.define('CArABU.technicalservices.ProjectCostModelBuilder',{
    singleton: true,
    prefPrefix: 'costAsOf-',
    build: function(modelType, newModelName) {
        var deferred = Ext.create('Deft.Deferred');
        var prefPrefix = CArABU.technicalservices.ProjectCostModelBuilder.prefPrefix;

        Rally.data.ModelFactory.getModel({
            type: modelType,
            success: function (model) {

                var default_fields = [{
                    name: '__cost',
                    convert: function(v, record){
                        var obj = record.get('Value');
                        if (obj){
                            obj = Ext.JSON.decode(obj);
                            return obj.cost;
                        }
                    }
                }, {
                    name: '__userDisplayName',
                    convert: function(v, record){
                        var obj = record.get('Value');
                        if (obj) {
                            obj = Ext.JSON.decode(obj);
                            return obj.userDisplayName;
                        }
                    }
                }, {
                    name: '__asOfDate',
                    convert: function(v, record){
                        var obj = record.get('Value');
                        if (obj) {
                            obj = Ext.JSON.decode(obj);
                            return Rally.util.DateTime.fromIsoString(obj.asOfDate);
                        }
                    }
                },{
                    name: '__comments',
                    convert: function(v, record){
                        var obj = record.get('Value');
                        if (obj){
                            obj = Ext.JSON.decode(obj);
                            return obj.comments;
                        }
                    }
                },{
                    name: '__avgDayRate',
                    convert: function(v, record){
                        var obj = record.get('Value');
                        if (obj){
                            obj = Ext.JSON.decode(obj);
                            return obj.avgDayRate;
                        }
                    }
                },{
                    name: '__noOfTeamMembers',
                    convert: function(v, record){
                        var obj = record.get('Value');
                        if (obj){
                            obj = Ext.JSON.decode(obj);
                            return obj.noOfTeamMembers;
                        }
                    }
                },{
                    name: '__teamType',
                    convert: function(v, record){
                        var obj = record.get('Value');
                        if (obj){
                            obj = Ext.JSON.decode(obj);
                            return obj.teamType;
                        }
                    }
                },{
                    name: '__sprintDays',
                    convert: function(v, record){
                        var obj = record.get('Value');
                        if (obj){
                            obj = Ext.JSON.decode(obj);
                            return obj.sprintDays;
                        }
                    }
                },{
                    name: '__averageVelocity',
                    convert: function(v, record){
                        var obj = record.get('Value');
                        if (obj){
                            obj = Ext.JSON.decode(obj);
                            return obj.averageVelocity;
                        }
                    }
                },{
                    name: '__averageStoryCount',
                    convert: function(v, record){
                        var obj = record.get('Value');
                        if (obj){
                            obj = Ext.JSON.decode(obj);
                            return obj.averageStoryCount;
                        }
                    }
                }];

                var new_model = Ext.define(newModelName, {
                    extend: model,
                    logger: new Rally.technicalservices.Logger(),
                    fields: default_fields,
                    prefPrefix: prefPrefix,
                    setCostForProject: function(cost, asOfDate, userName, comments, avgDayRate, noOfTeamMembers,teamType,sprintDays,averageVelocity,averageStoryCount){
                        var isoDate = Rally.util.DateTime.toIsoString(asOfDate),
                            name = this.prefPrefix + isoDate;

                        this.set('Name', name);

                        var obj = {
                            cost: cost,
                            asOfDate: isoDate,
                            userDisplayName: userName,
                            comments: comments,
                            avgDayRate: avgDayRate,
                            noOfTeamMembers: noOfTeamMembers,
                            teamType: teamType,
                            sprintDays:sprintDays,
                            averageVelocity:averageVelocity,
                            averageStoryCount:averageStoryCount
                        };
                        this.logger.log('setCostPerProject', name, obj, cost, asOfDate, userName, comments, avgDayRate, noOfTeamMembers,teamType,sprintDays);

                        this.set('Value', Ext.JSON.encode(obj));
                    }
                });
                deferred.resolve(new_model);
            }
        });
        return deferred;
    }
});
(function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('CArABU.technicalservices.RollupItem',{

    _rollupDataActualOpExCost: undefined,
    _rollupDataRemainingOpExCost: undefined,

    _rollupDataPreliminaryBudget: undefined,
    _rollupDataTotalCost: undefined,
    _rollupDataActualCost: undefined,
    _rollupDataRemainingCost: undefined,    
    
    _rollupDataToolTip: null,
    _notEstimated: true,
    children: undefined,

    useBudgetCalc: false,

    constructor: function(record) {
        this._rollupDataTotalCost = 0;
        this._rollupDataActualCost = 0;

        this.parent = record.get('Parent') && record.get('Parent').ObjectID || null;
        this.objectID = record.get('ObjectID');

        this._rollupDataPreliminaryBudget = this._calculatePreliminaryBudget(record.getData());
      //  this._rollupDataTotalCost = this.getPreliminaryBudget() || 0;
        this._rollupDataToolTip = this.getTooltip();
        this._rollupDataRemainingCost = this.getRemainingCostRollup();


        Ext.apply(this, record.getData());
    },
    addChild: function(objectID){
        if (!this.children){
            this.children = [];
        }
        this.children.push(objectID);
    },
    getExportRow: function(columns, ancestors){
        var rec = Ext.clone(ancestors);

        rec[this._type] = this.FormattedID;

        rec.type = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getTypePathDisplayName(this._type);
        _.each(columns, function(c){
            var field = c.costField || c.dataIndex || null;
            if (field){
                var data = this[field];
                
                if (Ext.isObject(data)){
                	if ( !Ext.isEmpty(data._refObjectName) ) {
                		rec[field] = data._refObjectName;
                	} else if ( Ext.isArray(data._tagsNameArray) ) {
                		rec[field] = Ext.Array.map(data._tagsNameArray, function(tag){
                			return tag.Name;
                		}).join(';');
                	} else {
                		rec[field] = data;
                	}
                } else if (Ext.isDate(data)){
                    rec[field] = Rally.util.DateTime.formatWithDefaultDateTime(data);
                } else {
                    rec[field] = data;
                }
            }
        }, this);
        return rec;
    },
    _calculatePreliminaryBudget: function(data){
        var preliminaryBudgetField = CArABU.technicalservices.PortfolioItemCostTrackingSettings.preliminaryBudgetField;
        if (data && data[preliminaryBudgetField]){
            //We need to do this in case we are using hte PreliminaryEstimate field, which is an object
            var val = data[preliminaryBudgetField].Value || data[preliminaryBudgetField];
            var cpu = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCostPerUnit(data.Project._ref);
            return cpu * val;
        }
        return null;
    },
    getTooltip: function(){

        var completed  = CArABU.technicalservices.PortfolioItemCostTrackingSettings.notAvailableText;
        if ((this.__actualUnits >= 0) && (this.__totalUnits >0 )){
            completed = Ext.String.format("{0} of {1}", this.__actualUnits, this.__totalUnits);
        }

        var calc_type_name = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeDisplayName();

        var html = Ext.String.format('{1} {0} Accepted<br/><br/>', calc_type_name, completed);

        html += Ext.String.format("<b>Preliminary Budget</b><br/>Preliminary Budget Field Value * Current Team Cost<br/><br/>");

        if (this.__totalUnits > 0){
            html += Ext.String.format('<b>Actual Cost</b><br/>{0} * Team Cost on Accepted Date for Story(s)<br/><br/>', this.__actualUnits || 0);

            if (this._notEstimated){
                html += '<b>Remaining Cost</b><br/>Preliminary Budget - Actual Cost or 0 (whichever is greater)<br/><br/>';
            } else {
                html += Ext.String.format('<b>Remaining Cost</b><br/>({1} - {0}) * Current Team Cost<br/><br/>', this.__actualUnits, this.__totalUnits);
            }
            html += '<b>Total Projected</b><br/>Actual Cost + Remaining Cost<br/><br/>';
        } else {
            html += '<br/><p>Portfolio Item has missing ' + calc_type_name + '.  Preliminary Budget is being used to calculate Projected and Remaining costs.</p>';
        }
        return html;
    },
    getTotalCostRollup: function(){
        //With this new version, this should always be Actual + Remaining
        //if (this._notEstimated){
            return this.getActualCostRollup() + this.getRemainingCostRollup() + this.getActualCostRollupOpEx() + this.getRemainingCostRollupOpEx();
        //}
        //return this._rollupDataTotalCost;
    },
    getActualCostRollup: function(){
        return this._rollupDataActualCost || 0;
    },
    getRemainingCostRollup: function(){
        if (this._notEstimated){
            return Math.max(this.getPreliminaryBudget() || 0 - this.getActualCostRollup(), 0);
        }
        return this._rollupDataRemainingCost || 0;
    },
    getActualCostRollupOpEx: function(){
        return this._rollupDataActualOpExCost || 0;
    },
    getRemainingCostRollupOpEx: function(){
        if (this._notEstimated){
            return Math.max(this.getPreliminaryBudget() || 0 - this.getActualCostRollupOpEx(), 0);
        }
        return this._rollupDataRemainingOpExCost || 0;
    },

    getPreliminaryBudget: function(){
        return this._rollupDataPreliminaryBudget || 0;
    }
});
})();
Ext.define('CArABU.technicalservices.DefectRollupItem', {
    extend: 'CArABU.technicalservices.RollupItem',
    constructor: function(record, totalFn, actualFn) {

        var data = record.data;
        if (record.getData && record.getData()){
            data = record.getData();
        }

        if (data){
            this.__totalUnits = totalFn(data);
            this.__actualUnits = actualFn(data);
            this._notEstimated = false;
            var costPerUnit =CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCostPerUnit(data.Project._ref),
                acceptedCostPerUnit = costPerUnit;

            if (data.AcceptedDate){
                acceptedCostPerUnit = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCostPerUnit(data.Project._ref, data.AcceptedDate);
            }
            var featureName = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getFeatureName();

            if(data.Requirement[featureName][CArABU.technicalservices.PortfolioItemCostTrackingSettings.expenseTypeField] == CArABU.technicalservices.PortfolioItemCostTrackingSettings.opExTypeValue ){
                this._rollupDataActualOpExCost = (this.__actualUnits * acceptedCostPerUnit) || 0;
                this._rollupDataRemainingOpExCost = Math.max((this.__totalUnits - this.__actualUnits),0) * costPerUnit;
                this._rollupDataTotalCost = this._rollupDataActualOpExCost + this._rollupDataRemainingOpExCost;  
            }else{
                this._rollupDataActualCost = (this.__actualUnits * acceptedCostPerUnit) || 0;
                this._rollupDataRemainingCost = Math.max((this.__totalUnits - this.__actualUnits),0) * costPerUnit;
                this._rollupDataTotalCost = this._rollupDataActualCost + this._rollupDataRemainingCost;
            }
            //this._rollupDataRemainingCost = this._rollupDataTotalCost - this._rollupDataActualCost;
            //this._rollupDataTotalCost = (this.__totalUnits * costPerUnit) || 0;

            this.parent = record.get('Requirement') && record.get('Requirement').ObjectID || null;

            this.objectID = data.ObjectID;

            this._rollupDataPreliminaryBudget = null;
            this._rollupDataToolTip = null;

            Ext.apply(this, data);
            this._buildToolTip();
        }
    },
    addChild: function(child){
        if (!this.children){
            this.children = [];
            this._rollupDataTotalCost = 0; //Need to clear this out becuase this is preliminary budget if there are no children
            this._rollupDataActualCost = 0;
            this._rollupDataRemainingCost = 0;
            this.__totalUnits = 0;
            this.__actualUnits = 0;
        }
        this.children.push(child);

        this.__totalUnits += child.__totalUnits || 0;
        this.__actualUnits += child.__actualUnits || 0;

        this._notEstimated = (this.__totalUnits === 0);

        this._rollupDataActualCost += child._rollupDataActualCost;
        this._rollupDataTotalCost += child._rollupDataTotalCost;
        this._rollupDataRemainingCost += child._rollupDataRemainingCost;
        this._buildToolTip();
    },
    _buildToolTip: function(){
        if (this.__totalUnits > 0){
            var acceptedDate = "Accepted Date";
            if (this.AcceptedDate){
                acceptedDate = Rally.util.DateTime.format(this.AcceptedDate,'Y-m-d');
            }
            this._rollupDataToolTip = Ext.String.format('<b>Actual (Accepted) Units:</b> {0}<br/>' +
                                                        '<b>Total Units: </b> {2}<br/><br/>' +
                                                        '<b>Actual Cost</b><br/>{0} Accepted * Team Cost on {1}<br/><br/>' +
                                                        '<b>Remaining Cost</b><br/>({2} Total - {0} Accepted) * Current Team Cost<br/><br/>' +
                                                        '<b>Total Projected</b><br/>Actual Cost + Remaining Cost', this.__actualUnits, acceptedDate, this.__totalUnits);
        }
    }
});
Ext.define('CArABU.technicalservices.LowestLevelPortfolioRollupItem',{
    extend: 'CArABU.technicalservices.RollupItem',

    processChildren: function(){

        this._rollupDataTotalCost = 0; //Need to clear this out becuase this is preliminary budget if there are no children
        this._rollupDataActualCost = 0;
        this._rollupDataRemainingCost = 0;
        this._rollupDataActualOpExCost = 0;
        this._rollupDataRemainingOpExCost = 0;
        this.__totalUnits = 0;
        this.__actualUnits = 0;
        var notEstimated = (!this.children || this.children.length === 0) ;

        Ext.Array.each(this.children, function(child){
            this.__totalUnits += child.__totalUnits || 0;
            this.__actualUnits += child.__actualUnits || 0;
            this._rollupDataActualCost += child._rollupDataActualCost;
            this._rollupDataRemainingCost += child._rollupDataRemainingCost;
            this._rollupDataActualOpExCost += child._rollupDataActualOpExCost;
            this._rollupDataRemainingOpExCost += child._rollupDataRemainingOpExCost;
            notEstimated = notEstimated && child._notEstimated;
        }, this);
        this._notEstimated = notEstimated;

        this._rollupDataToolTip = this.getTooltip();

        if (this._notEstimated && this.getPreliminaryBudget() > this.getActualCostRollup()){
            this._rollupDataRemainingCost = this.getPreliminaryBudget() - this.getActualCostRollup();
        }
        //This should always be actual + remaining...
        this._rollupDataTotalCost = this._rollupDataActualCost + this._rollupDataActualOpExCost +  this._rollupDataRemainingCost + this._rollupDataRemainingOpExCost;
    },
    addChild: function(child){
        if (!this.children){
            this.children = [];
            this._rollupDataTotalCost = 0; //Need to clear this out becuase this is preliminary budget if there are no children
            this._rollupDataActualCost = 0;
            this._rollupDataRemainingCost = 0;
            this._rollupDataActualOpExCost = 0;
            this._rollupDataRemainingOpExCost = 0;
            this.__totalUnits = 0;
            this.__actualUnits = 0;

        }
        this.children.push(child);

    }
});
Ext.define('CArABU.technicalservices.UpperLevelPortfolioRollupItem',{
    extend: 'CArABU.technicalservices.RollupItem',


    processChildren: function(){

        if (this.children && this.children.length > 0){
            var rollupDataTotal = 0,
                rollupDataActual = 0,
                rollupDataRemaining = 0,
                rollupDataActualOpEx = 0,
                rollupDataRemainingOpEx = 0,
                totalUnitsSum = 0,
                actualUnitsSum = 0,
                rollupItems = this.children || [],
                notEstimated = true,
                preliminaryBudget = 0;


            for (var i=0; i<rollupItems.length; i++){
                var item = rollupItems[i];
                item.processChildren();
                preliminaryBudget += item._rollupDataPreliminaryBudget;
                rollupDataTotal += item.getTotalCostRollup() ;
                rollupDataActual +=  item.getActualCostRollup();
                rollupDataRemaining += item.getRemainingCostRollup();
                rollupDataActualOpEx +=  item.getActualCostRollupOpEx();
                rollupDataRemainingOpEx += item.getRemainingCostRollupOpEx();   
                totalUnitsSum += item.__totalUnits || 0;
                actualUnitsSum += item.__actualUnits || 0;
                notEstimated = notEstimated && item._notEstimated;
            }

            this._rollupDataPreliminaryBudget = preliminaryBudget;
            this._notEstimated = notEstimated;
            this._rollupDataTotalCost = rollupDataTotal;
            this._rollupDataActualCost = rollupDataActual;
            this._rollupDataRemainingCost = rollupDataRemaining;
            this._rollupDataActualOpExCost = rollupDataActualOpEx;
            this._rollupDataRemainingOpExCost = rollupDataRemainingOpEx;
            this.__totalUnits = totalUnitsSum;
            this.__actualUnits = actualUnitsSum;
            this._rollupDataToolTip = this.getTooltip();
        }
    }
});

Ext.define('CArABU.technicalservices.UserStoryRollupItem', {
    extend: 'CArABU.technicalservices.RollupItem',
    constructor: function(record, totalFn, actualFn) {

        var data = record.data;
        if (record.getData && record.getData()){
            data = record.getData();
        }

        if (data){
            this.__totalUnits = totalFn(data);
            this.__actualUnits = actualFn(data);
            this._notEstimated = false;
            var costPerUnit =CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCostPerUnit(data.Project._ref),
                acceptedCostPerUnit = costPerUnit;

            if (data.AcceptedDate){
                acceptedCostPerUnit = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCostPerUnit(data.Project._ref, data.AcceptedDate);
            }

            var featureName = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getFeatureName();

            if(data[featureName][CArABU.technicalservices.PortfolioItemCostTrackingSettings.expenseTypeField] == CArABU.technicalservices.PortfolioItemCostTrackingSettings.opExTypeValue ){
                this._rollupDataActualOpExCost = (this.__actualUnits * acceptedCostPerUnit) || 0;
                this._rollupDataRemainingOpExCost = Math.max((this.__totalUnits - this.__actualUnits),0) * costPerUnit;
                this._rollupDataTotalCost = this._rollupDataActualOpExCost + this._rollupDataRemainingOpExCost;  
            }else{
                this._rollupDataActualCost = (this.__actualUnits * acceptedCostPerUnit) || 0;
                this._rollupDataRemainingCost = Math.max((this.__totalUnits - this.__actualUnits),0) * costPerUnit;
                this._rollupDataTotalCost = this._rollupDataActualCost + this._rollupDataRemainingCost;                            
            }

            //this._rollupDataRemainingCost = this._rollupDataTotalCost - this._rollupDataActualCost;
            //this._rollupDataTotalCost = (this.__totalUnits * costPerUnit) || 0;

            this.parent = record.get('PortfolioItem') && record.get('PortfolioItem').ObjectID || record.get('Parent') && record.get('Parent').ObjectID || null;

            this.objectID = data.ObjectID;

            this._rollupDataPreliminaryBudget = null;
            this._rollupDataToolTip = null;

            Ext.apply(this, data);
            this._buildToolTip();
        }
    },
    addChild: function(child){
        if (!this.children){
            this.children = [];
            this._rollupDataActualOpExCost = 0,
            this._rollupDataRemainingOpExCost = 0,
            this._rollupDataTotalCost = 0; //Need to clear this out becuase this is preliminary budget if there are no children
            this._rollupDataActualCost = 0;
            this._rollupDataRemainingCost = 0;
            this.__totalUnits = 0;
            this.__actualUnits = 0;


        }
        this.children.push(child);

        this.__totalUnits += child.__totalUnits || 0;
        this.__actualUnits += child.__actualUnits || 0;

        this._notEstimated = (this.__totalUnits === 0);
        this._rollupDataActualOpExCost += child._rollupDataActualOpExCost;
        this._rollupDataRemainingOpExCost += child._rollupDataRemainingOpExCost;
        this._rollupDataActualCost += child._rollupDataActualCost;
        this._rollupDataRemainingCost += child._rollupDataRemainingCost;
        this._rollupDataTotalCost += child._rollupDataTotalCost;

        this._buildToolTip();
    },
    _buildToolTip: function(){
        if (this.__totalUnits > 0){
            var acceptedDate = "Accepted Date";
            if (this.AcceptedDate){
                acceptedDate = Rally.util.DateTime.format(this.AcceptedDate,'Y-m-d');
            }
            this._rollupDataToolTip = Ext.String.format('<b>Actual (Accepted) Units:</b> {0}<br/>' +
                                                        '<b>Total Units: </b> {2}<br/><br/>' +
                                                        '<b>Actual Cost</b><br/>{0} Accepted * Team Cost on {1}<br/><br/>' +
                                                        '<b>Remaining Cost</b><br/>({2} Total - {0} Accepted) * Current Team Cost<br/><br/>' +
                                                        '<b>Total Projected</b><br/>Actual Cost + Remaining Cost', this.__actualUnits, acceptedDate, this.__totalUnits);
        }
    }
});


Ext.define('CArABU.technicalservices.CostTemplateColumn', {
    extend: 'Ext.grid.column.Template',
    alias: ['widget.costtemplatecolumn'],

    align: 'right',

    initComponent: function(){
        var me = this;

        Ext.QuickTips.init();

        me.tpl = new Ext.XTemplate('<tpl><div data-qtip="{[this.getTooltip(values)]}" style="cursor:pointer;text-align:right;">{[this.getCost(values)]}</div></tpl>',{
            costField: me.costField,

            getCost: function(values){
                if (values[this.costField] === null){
                    return CArABU.technicalservices.PortfolioItemCostTrackingSettings.notAvailableText;
                } else {
                    var html = CArABU.technicalservices.PortfolioItemCostTrackingSettings.formatCost(values[this.costField] || 0);
                    if (values._notEstimated && this.costField === '_rollupDataTotalCost'){
                        html = '<span class="picto icon-warning warning" style="color:#FAD200;font-size:10px;"></span>' + html;
                    }
                    return html;
                }
            },
            getTooltip: function(values){
                if (values._rollupDataToolTip){
                    return values._rollupDataToolTip;
                }
                return '';
            }

        });
        me.hasCustomRenderer = true;
        me.callParent(arguments);
    },
    getValue: function(){
        return values[this.costField] || 0;
    },
    defaultRenderer: function(value, meta, record) {
        var data = Ext.apply({}, record.data._rollupData); //, record.getAssociatedData());
        return this.tpl.apply(data);
    }
});


/**
 * Created this to allow for any custom fields to be used as the Preliminary Budget field
 * Requirements changed to only allow Preliminary Budget and Refined Estimate.
 */

Ext.define('CArABU.technicalservices.NumberFieldComboBox', {
    requires: [],
    extend: 'Rally.ui.combobox.FieldComboBox',
    alias: 'widget.numberfieldcombobox',
    _isNotHidden: function(field) {
        var validFields= ['PreliminaryEstimate','RefinedEstimate'],
            allowCustomNumberFields = true;

        if (!field.hidden) {

            if (Ext.Array.contains(validFields, field.name)) {
                return true;
            }

            //Allow for custom number fields
            if (allowCustomNumberFields && field.custom && field.attributeDefinition) {
                return (field.attributeDefinition.AttributeType === "INTEGER" ||
                field.attributeDefinition.AttributeType === "DECIMAL");
            }
        }
        return false;
    }
});

Ext.override(Rally.ui.combobox.PortfolioItemTypeComboBox, {
    getCurrentView: function () {
        return {piTypePicker: this.getRecord().get('_ref')};
    }
});


Ext.override(Rally.ui.gridboard.GridBoard, {
    setCurrentView: function(view) {
        this._setSharedViewProperties(this.plugins, view);

        if (view.toggleState === 'grid') {
            Ext.state.Manager.set(this._getGridConfig().stateId, _.pick(view, ['columns', 'sorters']));
        } else if (view.toggleState === 'board') {
            Ext.state.Manager.set(this._getBoardConfig().fieldsStateId, view.fields);
        }
        Ext.state.Manager.set(this.stateId, _.pick(view, ['toggleState']));

        //need to override so we can pass the view back to the app, alternatively we could override _setSharedViewProperties so that
        //we can set the value of hte additionalCmps
        this.fireEvent('viewchange', this, view);
    }
});


Ext.override(Rally.ui.grid.TreeGrid, {

    //_setColumnFlex: function(column) {
    //    if (column.width) {
    //        column.width =  column.width; //lets consider the derived columns
    //        //delete column.width;
    //    } else if (!_.isNumber(column.flex)) {
    //        column.flex = Rally.ui.grid.FieldColumnFactory.defaultFlexValue;
    //    }
    //},
    _mergeColumnConfigs: function(newColumns, oldColumns) {

        var mergedColumns= _.map(newColumns, function(newColumn) {
            var oldColumn = _.find(oldColumns, {dataIndex: this._getColumnName(newColumn)});
            if (oldColumn) {
                return this._getColumnConfigFromColumn(oldColumn);
            }

            return newColumn;
        }, this);


        mergedColumns = mergedColumns.concat(this.config.derivedColumns);

        return mergedColumns;
    },
    _getColumnConfigsBasedOnCurrentOrder: function(columnConfigs) {
         return _(this.headerCt.items.getRange()).map(function(column) {
             //override:  Added additional search for column.text
            return _.contains(columnConfigs, column.dataIndex) ? column.dataIndex : _.find(columnConfigs, {dataIndex: column.dataIndex, text: column.text});
        }).compact().value();
    },
    _restoreColumnOrder: function(columnConfigs) {

        var currentColumns = this._getColumnConfigsBasedOnCurrentOrder(columnConfigs);
        var addedColumns = _.filter(columnConfigs, function(config) {
            return !_.find(currentColumns, {dataIndex: config.dataIndex}) || Ext.isString(config);
        });

        return currentColumns.concat(addedColumns);
    },
    _applyStatefulColumns: function(columns) {
        if (this.alwaysShowDefaultColumns) {
            _.each(this.columnCfgs, function(columnCfg) {
                if (!_.any(columns, {dataIndex: this._getColumnName(columnCfg)})) {
                    columns.push(columnCfg);
                }
            }, this);
        }
        if (this.config && this.config.derivedColumns){
            this.columnCfgs = columns.concat(this.config.derivedColumns);
        } else {
            this.columnCfgs = columns;
        }
    },
    _isStatefulColumn: function(columnName) {

        if (this.config && this.config.derivedColumns && this.config.derivedColumns.length > 0){
            var derivedColNames = _.pluck(this.config.derivedColumns, 'dataIndex');
            if (Ext.Array.contains(derivedColNames, columnName)){
                return false;
            }
        }

        if (!this.allColumnsStateful) {
            columnName = columnName.toLowerCase();

            if (this.store.enableHierarchy && columnName === this.treeColumnDataIndex.toLowerCase()) {
                return false;
            }

            if (this.enableRanking && columnName === this.rankColumnDataIndex.toLowerCase()) {
                return false;
            }
        }

        return true;
    }
});

Ext.define('CArABU.technicalservices.promise.ParallelThrottle',{
    requires: ['Deft.promise.Promise'],
    statics: {

        throttle: function (fns, maxParallelCalls, scope) {

            if (maxParallelCalls <= 0 || fns.length < maxParallelCalls){
                return Deft.promise.Chain.parallel(fns, scope);
            }


            var parallelFns = [],
                fnChunks = [],
                idx = -1;

            for (var i = 0; i < fns.length; i++) {
                if (i % maxParallelCalls === 0) {
                    idx++;
                    fnChunks[idx] = [];
                }
                fnChunks[idx].push(fns[i]);
            }

            _.each(fnChunks, function (chunk) {
                parallelFns.push(function () {
                    return Deft.promise.Chain.parallel(chunk, scope);
                });
            });

            return Deft.Promise.reduce(parallelFns, function(groupResults, fnGroup) {
                return Deft.Promise.when(fnGroup.call(scope)).then(function(results) {
                    groupResults = groupResults.concat(results || []);
                    return groupResults;
                });
            }, []);
        }
    }
});

(function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('CArABU.technicalservices.RollupCalculator', {
        extend: 'Ext.Base',

        mixins: {
            observable: 'Ext.util.Observable'
        },

        rollupItems: undefined,

        constructor: function (config) {
            this.mixins.observable.constructor.call(this, config);
            this.rollupItems = {};
            this.portfolioItemType = config.portfolioItemType;
            this.projectCostDate = config.projectCostDate || new Date();
        },
        addRollupRecords: function(portfolioItemRecordHash, defects){
            var portfolioItemTypes = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemTypes();

            this.rootObjectIDs = [];
            for (var i=portfolioItemTypes.length -1; i >= 0; i--){
                var portfolioRecords = portfolioItemRecordHash[portfolioItemTypes[i]] || [];
                this._addPortfolioRecords(portfolioRecords);
            }
            var stories = portfolioItemRecordHash['hierarchicalrequirement'];
            this._addStories(stories);
            this._addDefects(defects);
            this._calculatePortfolioItemRollups();
        },
        getRollupData: function(record){
            if (!record){
                return null;
            }
            var objectID = record.ObjectID || record.get('ObjectID');
            return this.rollupItems[objectID] || null;
        },
        /**
         * Adds records needed to calculate the rollup data
         * @param records
         */
        _addPortfolioRecords: function(records){
            if (!records || records.length === 0){
                return;
            }

            var type = records[0].get('_type').toLowerCase(),
                rollupItemType = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getRollupItemType(type),
                rootPortfolioItem = this.portfolioItemType.toLowerCase();

            if (rollupItemType){ //this is a portfolio item type
                for (var i=0; i<records.length; i++){
                    var r = records[i],
                        oid = r.get('ObjectID'),
                        parentObjectID = r.get('Parent') && r.get('Parent').ObjectID,
                        item = Ext.create(rollupItemType, r);

                    this.rollupItems[oid] = item;

                    if (parentObjectID && this.rollupItems[parentObjectID]){
                        this.rollupItems[parentObjectID].addChild(item);
                    }

                    if (type === rootPortfolioItem){
                        this.rootObjectIDs.push(oid);
                    }
                }
            }
        },

        _addStories: function(stories){
            var parents = [],
            //rollupItems = this.rollupItems,
                totalFn = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings().totalUnitsForStoryFn,
                actualFn = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings().actualUnitsForStoryFn;

            for(var i =0; i < stories.length; i++){
                var item = Ext.create('CArABU.technicalservices.UserStoryRollupItem', stories[i], totalFn, actualFn);

                this.rollupItems[item.ObjectID] = item;

                if (item.parent && this.rollupItems[item.parent]){
                    parents.push(item.parent);
                    this.rollupItems[item.parent].addChild(item);
                }
            }

        },

        _addDefects: function(defects){
            var parents = [],
            //rollupItems = this.rollupItems,
                totalFn = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings().totalUnitsForStoryFn,
                actualFn = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings().actualUnitsForStoryFn;

            for(var i =0; i < defects.length; i++){
                var item = Ext.create('CArABU.technicalservices.DefectRollupItem', defects[i], totalFn, actualFn);

                this.rollupItems[item.ObjectID] = item;

                if (item.parent && this.rollupItems[item.parent]){
                    parents.push(item.parent);
                    this.rollupItems[item.parent].addChild(item);
                }
            }

        },        

        _calculatePortfolioItemRollups: function(){
            for (var i=0; i<this.rootObjectIDs.length; i++){
                var item = this.rollupItems[this.rootObjectIDs[i]];
                if (item && item._type.toLowerCase() === this.portfolioItemType.toLowerCase()){
                    item.processChildren();
                }

            }
        },
        updateModels: function(records){
            records = records || [];
            var unloadedModels = [],
                rollupItems = this.rollupItems;

            for (var i=0; i<records.length; i++){
                var r = records[i],
                    rollupItem = rollupItems[r.get('ObjectID')] || null;
                if (rollupItem){
                    r.set('_rollupData', rollupItem);
                } else {
                    unloadedModels.push(r);
                }
            }
            return unloadedModels;
        },
        destroy: function(){
            this.rollupItems = {};
        }
    });
}) ();
(function() {
    var Ext = window.Ext4 || window.Ext;

    ///**
    // * Class to load lots of data and update as status is made.
    // */
    Ext.define('CArABU.technicalservices.RollupDataLoader',{

        storyModelName: 'hierarchicalrequirement',
        defectModelName: 'defect',

        mixins: {
            observable: 'Ext.util.Observable'
        },

        model: undefined,
        filters: undefined,
        fetch: undefined,

        maxParallelCalls: 6,
        maxListSize: 50,

        constructor: function (config) {
            this.mixins.observable.constructor.call(this, config);
            this.portfolioItemTypes = config.portfolioItemTypes || [];
        },
        loadTree: function(config){
            this.rootConfig = config;
            this.additionalFetch = config.fetch;
            this.load(config.model);
        },
        loadDescendants: function(rootRecords, additionalFetch){
            this.rootRecords = rootRecords;
            this.additionalFetch = additionalFetch || [];
            if (!rootRecords || rootRecords.length === 0){
                this.fireEvent('loaderror', "No root records to load descendents for.");
                return;
            }
            var model = this.getChildPortfolioItemType(rootRecords[0].get('_type'));
            this.load(model);
        },

        load: function(model){

            if (this.portfolioItemTypes.length === 0){
                this.fireEvent('loaderror', "Portfolio Item Types not initialized.");
                return;
            }

            this.storyFetch = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getStoryFetch(this.additionalFetch);
            this.portfolioItemFetch = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemFetch(this.additionalFetch);

            var idx = _.indexOf(this.portfolioItemTypes, model.toLowerCase());
            var fns = [];

            for (var i=idx; i>=0; i--){
                fns.push(this.fetchPortfolioItems);
            }
            fns.push(this.fetchUserStories);
            fns.push(this.fetchDefects);
            this.recordsHash = {};

            Deft.Chain.pipeline(fns, this).then({
                success: function(stories){
                    this.fireEvent('rollupdataloaded', this.recordsHash, _.flatten(stories));
                },
                failure: function(msg){
                    this.fireEvent('loaderror', msg);
                },
                scope: this
            });
        },
        fetchRoot: function(){
            this.fireEvent('statusupdate', "Loading artifacts");
            var config = this.rootConfig || {};
            config.fetch = config.fetch.concat(this.getRequiredFetchFields(config.model));

            return this.fetchWsapiRecordsWithPaging(config);
        },
        getChildPortfolioItemType: function(type){
            var idx = _.indexOf(this.portfolioItemTypes, type.toLowerCase());
            if (idx > 0){
                return this.portfolioItemTypes[idx-1];
            }
            return this.storyModelName;
        },
        fetchPortfolioItems: function(parentRecords){
            parentRecords = parentRecords || this.rootRecords;
            if (!parentRecords || parentRecords.length === 0){
                return this.fetchRoot();
            }
            parentRecords = _.flatten(parentRecords);

            var parentType = parentRecords[0].get('_type');
            this.recordsHash[parentType] = parentRecords;

            var type = this.getChildPortfolioItemType(parentType),
                fetch = this.portfolioItemFetch.concat(this.getRequiredFetchFields(type)),
                chunks = this._getChunks(parentRecords, 'Children', 'Count');

            return this.fetchChunks(type, fetch, chunks, "Parent.ObjectID", Ext.String.format("Please Wait... Loading Children for {0} Portfolio Items", parentRecords.length));
        },
        _getChunks: function(parentRecords, countField, countFieldAttribute){
            var chunks = [],
                childCount = 0,
                maxListSize = this.maxListSize,
            //childCountTarget = 200,
                idx = 0;

            chunks[idx] = [];
            _.each(parentRecords, function(r){
                var count = r.get(countField);
                if (countFieldAttribute && count){
                    count = count[countFieldAttribute];
                }
                if (count > 0){
                    if (chunks[idx].length >= maxListSize){ //childCount + count > childCountTarget ||
                        idx++;
                        chunks[idx] = [];
                        childCount = 0;
                    }
                    childCount += count;
                    chunks[idx].push(r.get('ObjectID'));
                }
            });
            return chunks;
        },

        fetchUserStories: function(parentRecords){
            parentRecords = parentRecords || this.rootRecords;
            if (!parentRecords || parentRecords.length === 0){
                return this.fetchRoot();
            }
            parentRecords = _.flatten(parentRecords);

            var parentType = parentRecords[0].get('_type');
            this.recordsHash[parentType] = parentRecords;

            var type = this.storyModelName,
                fetch = this.storyFetch.concat(this.getRequiredFetchFields(type)),
                chunks = this._getChunks(parentRecords, 'UserStories','Count'),
                featureParentName = this.featureName + ".ObjectID";

            return this.fetchChunks(type, fetch, chunks, featureParentName, Ext.String.format("Please Wait... Loading User Stories for {0} Portfolio Items", parentRecords.length));
        },

        fetchDefects: function(parentRecords){
            parentRecords = parentRecords || this.rootRecords;
            if (!parentRecords || parentRecords.length === 0){
                return this.fetchRoot();
            }
            parentRecords = _.flatten(parentRecords);

            var parentType = parentRecords[0].get('_type');
            this.recordsHash[parentType] = parentRecords;

            var type = this.defectModelName,
                fetch = this.storyFetch.concat(this.getRequiredFetchFields(type)),
                chunks = this._getChunks(parentRecords, 'Defects','Count'),
                requirementID = "Requirement.ObjectID";

            return this.fetchChunks(type, fetch, chunks, requirementID, Ext.String.format("Please Wait... Loading Defects for {0} Portfolio Items", parentRecords.length));
        },

        fetchChunks: function(type, fetch, chunks, chunkProperty, statusString){

            if (chunks && chunks.length > 0 && chunks[0].length===0){
                return Promise.resolve([]);
            }

            this.fireEvent('statusupdate', statusString);

            var promises = [];
            _.each(chunks, function(c){
                var filters = _.map(c, function(ids){ return {property: chunkProperty, value: ids }; }),
                    config = {
                        model: type,
                        fetch: fetch,
                        filters: Rally.data.wsapi.Filter.or(filters)
                    };
                promises.push(function(){ return this.fetchWsapiRecords(config); });
            });

            return this.throttle(promises, this.maxParallelCalls, this);
        },
        fetchWsapiRecords: function(config){
            var deferred = Ext.create('Deft.Deferred');

            Ext.create('Rally.data.wsapi.Store',{
                model: config.model,
                fetch: config.fetch,
                filters: config.filters,
                limit: 'Infinity'
            }).load({
                callback: function(records, operation){
                    if (operation.wasSuccessful()){
                        deferred.resolve(records);
                    } else {
                        deferred.reject('fetchWsapiRecords error: ' + operation.error.errors.join(','));
                    }
                },
                scope: this
            });
            return deferred;
        },

        getRequiredFetchFields: function(type){
            var featureName = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getFeatureName();
            if (type.toLowerCase() === this.storyModelName){
                return ['Parent','PortfolioItem','ObjectID','Defects', featureName , CArABU.technicalservices.PortfolioItemCostTrackingSettings.expenseTypeField];
            }

            if (type.toLowerCase() === this.defectModelName){
                return ['Parent','PortfolioItem','ObjectID','Requirement',featureName , CArABU.technicalservices.PortfolioItemCostTrackingSettings.expenseTypeField];
            }

            return  ['Children', 'UserStories','Parent','ObjectID',featureName , CArABU.technicalservices.PortfolioItemCostTrackingSettings.expenseTypeField];
        },

        throttle: function (fns, maxParallelCalls, scope) {

            if (maxParallelCalls <= 0 || fns.length < maxParallelCalls){
                return Deft.promise.Chain.parallel(fns, scope);
            }


            var parallelFns = [],
                fnChunks = [],
                idx = -1;

            for (var i = 0; i < fns.length; i++) {
                if (i % maxParallelCalls === 0) {
                    idx++;
                    fnChunks[idx] = [];
                }
                fnChunks[idx].push(fns[i]);
            }

            _.each(fnChunks, function (chunk) {
                parallelFns.push(function () {
                    return Deft.promise.Chain.parallel(chunk, scope);
                });
            });

            return Deft.Promise.reduce(parallelFns, function(groupResults, fnGroup) {
                return Deft.Promise.when(fnGroup.call(scope)).then(function(results) {
                    groupResults = groupResults.concat(results || []);
                    return groupResults;
                });
            }, []);
        },
        fetchWsapiCount: function(model, query_filters){
            var deferred = Ext.create('Deft.Deferred');

            Ext.create('Rally.data.wsapi.Store',{
                model: model,
                fetch: ['ObjectID'],
                filters: query_filters,
                limit: 1,
                pageSize: 1
            }).load({
                callback: function(records, operation, success){
                    if (success){
                        deferred.resolve(operation.resultSet.totalRecords);
                    } else {
                        deferred.reject(Ext.String.format("Error getting {0} count for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                    }
                }
            });
            return deferred;
        },
        fetchWsapiRecordsWithPaging: function(config){
            var deferred = Ext.create('Deft.Deferred'),
                promises = [],
                me = this;

            this.fetchWsapiCount(config.model, config.filters).then({
                success: function(totalCount){
                    var store = Ext.create('Rally.data.wsapi.Store',{
                            model: config.model,
                            fetch: config.fetch,
                            filters: config.filters,
                            pageSize: 200
                        }),
                        totalPages = Math.ceil(totalCount/200);

                    var pages = _.range(1,totalPages+1,1);

                    this.fireEvent('statusupdate',Ext.String.format(config.statusDisplayString || "Loading {0} artifacts", totalCount));

                    _.each(pages, function(page){
                        promises.push(function () {return me.loadStorePage(page, store);});
                    });

                    this.throttle(promises, 12, me).then({
                        success: function(results){
                            deferred.resolve(_.flatten(results));
                        },
                        failure: function(msg){
                            deferred.reject(msg);
                        },
                        scope: me
                    });
                },
                failure: function(msg){
                    deferred.reject(msg);
                },
                scope: me
            });
            return deferred;
        },
        loadStorePage: function(pageNum, store){
            var deferred = Ext.create('Deft.Deferred');

            store.loadPage(pageNum, {
                callback: function(records, operation){
                    if (operation.wasSuccessful()){
                        deferred.resolve(records);
                    } else {
                        deferred.reject('loadStorePage error: ' + operation.error.errors.join(','));
                    }
                },
                scope: this
            });

            return deferred;
        }

    });
})();
Ext.define('CArABU.technicalservices.PortfolioItemCostTrackingSettings', {
    singleton: true,

    /**
     * App Settings
     */
    selectedCalculationType: undefined,
    /**
     * Currency display settings to pass into the Ext.util.Format currency function
     */
    currencySign: '$',
    currencyPrecision: 0,
    currencyEnd: false,

    normalizedCostPerUnit: 1,

    opExTypeValue : 'OpEx',
    preliminaryBudgetField: 'PreliminaryEstimate',

    expenseTypeField: 'c_ExpenseType',
    /**
     * App configurations
     */

    tooltipActualCost: 'actualcost ',
    tooltipTotalCost: 'totalcost',
    tooltipRemainingCost: 'remaining cost',
    tooltipPreliminaryBudget: 'preliminary budget',

    calculationTypes: {
        points: {
            key: 'points',
            label: 'Based on Story Points',
            displayName: 'Story Points',
            defaultColumns: ['Name', 'Project', 'PlanEstimate', 'LeafStoryPlanEstimateTotal','AcceptedLeafStoryPlanEstimateTotal','AcceptedDate'],
            requiredStoryFetch: ['ScheduleState','PortfolioItem','PlanEstimate','AcceptedDate'],
            requiredTaskFetch: [],
            tooltips: {
                _rollupDataActualCost: 'Actual Cost is the sum of the Accepted Story Plan Estimates <i>for all stories in scope</i> * Cost Per Unit for the project that the top level story resides in.',
                _rollupDataRemainingCost: 'Remaining Cost is the Total Projected Cost - Actual Cost',
                _rollupDataTotalCost: 'Total Projected Cost is the sum of the Plan Estimate <i>for each story in scope</i>* Cost Per Unit for the project that the top level story resides in.  <br/><br/> If a Portfolio Item does not have any estimated stories and the Preliminary Budget is greater than the Portfolio Item\'s Actual Cost, then the Preliminary Budget will be used for the Total Projected Cost.',
                _rollupDataPreliminaryBudget: 'The prelimary budget will be calculated by multiplying the value of the selected field by the Cost per Unit for the project of the portfolio item. <br/><br/> Note that for portfolio item types beyond the lowest level, this is calculated from the preliminary estimate of the portfolio item, not from the sum of the portfolio item children.  If the selected field value is null, then -- will be displayed.'
            },
            actualUnitsForStoryFn: function(data){
                if (data && data.PlanEstimate && Ext.Array.contains(CArABU.technicalservices.PortfolioItemCostTrackingSettings.completedScheduleStates, data.ScheduleState)) {
                    return data && data.PlanEstimate || 0;
                }
                return 0;
            },
            totalUnitsForStoryFn: function(data){
                return data && data.PlanEstimate || 0;
            }
        },
        taskHours: {
            key: 'taskHours',
            displayName: 'Task Actuals',
            label: 'Based on Task Actuals',
            defaultColumns: ['Name','Project'],
            requiredStoryFetch: ['ScheduleState','PortfolioItem','TaskEstimateTotal','TaskActualTotal','TaskRemainingTotal','AcceptedDate'],
            requiredTaskFetch: ['ToDo','Actuals'],
            tooltips: {
                _rollupDataActualCost: 'Actual Cost is the sum of the Task Actuals <i>for all stories in scope</i> * Cost Per Unit for the project that the top level story resides in.',
                _rollupDataRemainingCost: 'Remaining Cost is the sum of the ToDo <i>for all stories in scope</i> * Cost Per Unit for the project that the top level story resides in.',
                _rollupDataTotalCost: 'Total Projected Cost is the sum of the Task Estimate Total <i>for each story in scope</i> * Cost Per Unit for the project that the top level story resides in.  <br/><br/> If a Portfolio Item does not have any estimated stories and the Preliminary Budget is greater than the Portfolio Item\'s Actual Cost, then the Preliminary Budget will be used for the Total Projected Cost.',
                _rollupDataPreliminaryBudget: 'The prelimary budget will be calculated by multiplying the value of the selected field by the Cost per Unit for the project of the portfolio item. <br/><br/> Note that for portfolio item types beyond the lowest level, this is calculated from the preliminary estimate of the portfolio item, not from the sum of the portfolio item children.  If the selected field value is null, then -- will be displayed.'
            },
            actualUnitsForStoryFn: function(data){ return data.TaskActualTotal || 0; },
            totalUnitsForStoryFn: function(data){
                return (data && data.TaskActualTotal || 0) + (data && data.TaskRemainingTotal || 0);
            },
            actualUnitsForTaskFn: function(data){
                return data && data.Actuals || 0;
            },
            totalUnitsForTaskFn: function(data){
                return (data && data.ToDo || 0) + (data && data.Actuals || 0);
            }
        //},
        //timesheets: {
        //    key: 'timesheets',
        //    displayName: 'Time Spent',
        //    label: 'Based on Timesheets',
        //    defaultColumns: ['Name','Project'],
        //    requiredStoryFetch: [],
        //    requiredTaskFetch: [],
        //    disabled: true,
        //    actualUnitsForStoryFn: function(data){ return 0; },
        //    actualUnitsForTaskFn: function(data){ return 0; },
        //    totalUnitsForStoryFn: function(data){  return 0; },
        //    totalUnitsForTaskFn: function(data){  return 0; }
        }
    },

    /**
     * Required fetch fields in addition to what the Tree might fetch.  We need these for the rollup data fetch lists and for group by Release
     */
    requiredPortfolioItemFetch: ['UserStories'],
    requiredFetch: ['ObjectID','FormattedID','Project','Parent','Children','Release','Name'],

    notAvailableText: '--',

    completedScheduleStates: [],

    portfolioItemTypes: [],

    currencyData: [
        {name: "US Dollars", value: "$"},
        {name: "Euro", value: "&#128;"},
        {name: "Japanese Yen", value: "&#165;"},
        {name: "Brazilian Real", value: "R$"},
        {name: "South African Rand", value: "R"}
    ],
    getFeatureName: function(){
        return this.portfolioItemTypes[0].name.replace(/\s/g, '');
    },
    getHeaderTooltip: function(field){
        var settings = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings();
        return settings.tooltips[field] || null;

    },
    /**
     * setProjectCostHistory
     * @param projectCostHistoryRecords
     */
    projectCostPerUnit: {},
    projectCostDate: undefined,

    setProjectCostHistory: function(projectCostHistoryRecords){

        var hash = {};
        Ext.Array.each(projectCostHistoryRecords, function(r){
            var projectRef = r.get('Project') && r.get('Project')._ref;
            if (projectRef){
                if (!hash[projectRef]){
                    hash[projectRef] = [];
                }
                hash[projectRef].push(r.getData());
            }
        });

        CArABU.technicalservices.PortfolioItemCostTrackingSettings.projectCostPerUnit = hash;
        console.log('setProjectCostHistory',CArABU.technicalservices.PortfolioItemCostTrackingSettings.projectCostPerUnit)
    },
    getCostPerUnit: function(project_ref, asOfDate){

        var projectCostHistory = CArABU.technicalservices.PortfolioItemCostTrackingSettings.projectCostPerUnit[project_ref];
        if (!projectCostHistory || projectCostHistory.length === 0){
            return CArABU.technicalservices.PortfolioItemCostTrackingSettings.normalizedCostPerUnit;
        }

        asOfDate = asOfDate || new Date();
        projectCostHistory = _.sortBy(projectCostHistory, function(obj){ return projectCostHistory.__asOfDate; });

        var cost = projectCostHistory[projectCostHistory.length-1];
        Ext.Array.each(projectCostHistory, function(obj){
            if (Rally.util.DateTime.getDifference(asOfDate, obj.__asOfDate,'day') >= 0){
                cost = obj.__cost;
                return false;
            }
        },this,true);
        return cost;

    },

    isProjectUsingNormalizedCost: function(project_ref){
        if (CArABU.technicalservices.PortfolioItemCostTrackingSettings.projectCostPerUnit[project_ref]){
            return false;
        }
        return true;
    },
    /**
     * END Project Cost History updates...
     */
    setCalculationType: function(type){
        //Check that actuals is on, and warn user if it is not.
        if (type === 'taskHours'){
            Rally.data.ModelFactory.getModel({
                type: 'task',
                success: function(model){
                    var field = model.getField('Actuals');
                    if (field && field.hidden){
                        Rally.ui.notify.Notifier.showWarning({message: 'The Task Actuals field is not visible in the current project.  As a result, Task Actuals values may be 0.'});
                    }
                }
            });
        }


        if (CArABU.technicalservices.PortfolioItemCostTrackingSettings.calculationTypes[type]){
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.selectedCalculationType = type;
        } else {
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.selectedCalculationType = 'points';
        }
    },
    /**
     * getPortfolioItemTypeLevel
     * @param modelName
     * Given a model name, this function returns the level of portfolio item the model name is:
     *  0 = Lowest Level (Feature)
     *  1 = Second Level (e.g. Initiative)
     *  ...
     *  return -1 if the modelName is not a portfolio item type
     */
    getPortfolioItemTypeLevel: function(modelName){
        var idx = _.indexOf(CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemTypes(), modelName.toLowerCase());
        return idx;
    },
    getRollupItemType: function(type){
        var idx = _.indexOf(CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemTypes(), type.toLowerCase());
        if (idx > 0){
            return 'CArABU.technicalservices.UpperLevelPortfolioRollupItem';
        }
        if (idx === 0){
            return 'CArABU.technicalservices.LowestLevelPortfolioRollupItem';
        }
        return null;
    },
    getPortfolioItemTypes: function(){
        return _.map( this.portfolioItemTypes, function(p){ return p.typePath.toLowerCase(); });
    },
    getPortfolioItemTypeObjects: function(){
        return this.portfolioItemTypes;
    },
    getTypePathDisplayName: function(piTypePath){
        if (piTypePath.toLowerCase() === 'hierarchicalrequirement'){
            return 'User Story';
        }

        var piDisplayName = '';

        Ext.Array.each(this.portfolioItemTypes, function(p){
            if (p.typePath.toLowerCase() === piTypePath.toLowerCase()){
                piDisplayName = p.name;
                return false;
            }
        });
        return piDisplayName;
    },
    getCalculationTypeSettings: function(){
        return CArABU.technicalservices.PortfolioItemCostTrackingSettings.calculationTypes[CArABU.technicalservices.PortfolioItemCostTrackingSettings.selectedCalculationType] || CArABU.technicalservices.PortfolioItemCostTrackingSettings.calculationTypes.points;
    },
    getCalculationTypeDisplayName: function(){
        return CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings().displayName || 'Unknown';
    },
    formatCost: function(cost){
        return Ext.util.Format.currency(cost,
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencySign,
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencyPrecision,
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencyEnd);
    },

    /**
     * This function returns all the fields that we want to return for the tree. It is built depending on the settings for cost calculations so
     * that we know to include all necessary fields.
     * @param fetch
     * @returns {*}
     */
    getTreeFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }


        return Ext.Array.merge(fetch, CArABU.technicalservices.PortfolioItemCostTrackingSettings.getStoryFetch(),
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemFetch(),
            (CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings().requiredTaskFetch || []));

    },
    getStoryFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }

        return Ext.Array.merge(fetch, CArABU.technicalservices.PortfolioItemCostTrackingSettings.requiredFetch,
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.getCalculationTypeSettings().requiredStoryFetch);

    },
    getPortfolioItemFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }

        return Ext.Array.merge(CArABU.technicalservices.PortfolioItemCostTrackingSettings.requiredFetch,
            CArABU.technicalservices.PortfolioItemCostTrackingSettings._getPreliminaryBudgetFields(),
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.requiredPortfolioItemFetch);
    },
    _getPreliminaryBudgetFields: function(){
        var preliminaryBudgetFields = [CArABU.technicalservices.PortfolioItemCostTrackingSettings.preliminaryBudgetField];
        if (CArABU.technicalservices.PortfolioItemCostTrackingSettings.preliminaryBudgetField === "PreliminaryEstimate"){
            preliminaryBudgetFields.push('Value');
        }
        return preliminaryBudgetFields;
    },
    getFields: function(config) {

        var current_calculation_type = (config && config.selectedCalculationType) || 'points';

        var currency_store = Ext.create('Rally.data.custom.Store', {
            data: CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencyData
        });
        var labelWidth = 100;

        var cost_items = [];
        _.each(CArABU.technicalservices.PortfolioItemCostTrackingSettings.calculationTypes, function(obj, key){
            cost_items.push({
                boxLabel: obj.label || key,
                name: 'selectedCalculationType',
                inputValue: key,
                disabled: obj.disabled || false,
                checked: key === current_calculation_type
            });
        });

        var featureName = this.portfolioItemTypes[0].typePath;
        
        return [{
            xtype: 'rallyfieldcombobox',
            name: 'expenseTypeField',
            value: config.expenseTypeField,
            fieldLabel: 'Choose Expense Type field',
            model: featureName,
            labelWidth: labelWidth,
            margin: '10 0 10 0'
        },{
            xtype: 'rallycombobox',
            name: 'currencySign',
            store: currency_store,
            displayField: 'name',
            valueField: 'value',
            fieldLabel:  'Currency',
            labelWidth: labelWidth,
            margin: '10 0 10 0'
        },{
            xtype: 'numberfieldcombobox',
            name: 'preliminaryBudgetField',
            fieldLabel: 'Calculate Preliminary Budget using',
            model: 'PortfolioItem',
            labelWidth: labelWidth,
            margin: '10 0 10 0'
        },{
            xtype: 'radiogroup',
            fieldLabel: 'Calculate Cost',
            columns: 1,
            vertical: true,
            labelWidth: labelWidth,
            margin: '10 0 10 0',
            items: cost_items
        },{
            xtype: 'rallytextfield',
            name: 'normalizedCostPerUnit',
            fieldLabel: 'Normalized Cost Per Unit',
            labelWidth: labelWidth,
            width: 200,
            value: config.normalizedCostPerUnit,
            margin: '25 0 0 0'
        }];
    }
});

Ext.define('CArABU.technicalservices.SnapshotNameDialog',{
    extend: 'Rally.ui.dialog.Dialog',

    width: 300,
    layout: 'fit',
    closable: true,
    draggable: true,

    constructor: function(config) {
        this.mergeConfig(config);

        this.callParent([this.config]);
    },

    beforeRender: function() {
        this.callParent(arguments);

        this.selectedProject = null;

        this.addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    cls: 'primary rly-small',
                    disabled: true,
                    handler: function() {
                        this.fireEvent('takesnapshot', this.getName());
                        this.close();
                    },
                    itemId: 'doneButton',
                    scope: this,
                    iconCls: 'icon-snapshot'
                },
                {
                    xtype: 'rallybutton',
                    iconCls: 'icon-cancel',
                    cls: 'secondary rly-small',
                    handler: this.close,
                    scope: this
                }
            ]
        });

         var pt = this.add({
            xtype: 'rallytextfield',
            itemId: 'txtName',
            maxLength: 200
        });
        pt.on('change', function(txt, newValue){
            this.down('#doneButton').setDisabled(!newValue || newValue.length === 0);
        }, this);

    },
    getName: function(){
        return this.down('#txtName').getValue();
    }


});

Ext.define('CArABU.technicalservices.SnapshotBulkRecordMenuItem', {
    alias: 'widget.snapshotbulkmenuitem',
    extend: 'Rally.ui.menu.bulk.MenuItem',

    config: {
        onBeforeAction: function(){
//            console.log('onbeforeaction');
        },

        /**
         * @cfg {Function} onActionComplete a function called when the specified menu item action has completed
         * @param Rally.data.wsapi.Model[] onActionComplete.successfulRecords any successfully modified records
         * @param Rally.data.wsapi.Model[] onActionComplete.unsuccessfulRecords any records which failed to be updated
         */
        onActionComplete: function(){
            console.log('onActionComplete');
        },

        text: 'Take Snapshot...',

        handler: function () {
            this._getSnapshotName();
        },
        predicate: function (records) {
            var type = null;
            //The goal here is to only allow selection of portfolio items and to
            //not allow mixed selections (e.g. not allow initiatives and features both in one snapshot)
            if (records && records.length > 0){
                type = records[0].get('_type').toLowerCase();
            }
            return _.every(records, function (record) {
                var recordType = record.get('_type').toLowerCase(),
                    isPortfolioItem = /portfolioitem/.test(recordType);

                if (!type){
                    return isPortfolioItem;
                }
                return type === recordType;
            });
        },
        _getSnapshotName: function(){
            Ext.create('CArABU.technicalservices.SnapshotNameDialog', {
                autoShow: true,
                draggable: true,
                width: 300,
                title: 'Enter Snapshot Name',
                listeners: {
                    takesnapshot: this._saveSnapshot,
                    scope: this
                }
            });
        },
        _saveSnapshot: function(name) {
            console.log('_saveSnapshot', name, this.records);

            if (!this.records || this.records.length === 0){
                return;
            }

            var snapshotSettings = {};
            Ext.Array.each(this.records, function (r) {
                snapshotSettings[r.get('ObjectID')] = r.get('_rollupData')._rollupDataTotalCost;
            });

            var type = this.records[0].get('_type');

            Rally.data.ModelFactory.getModel({
                type: 'Preference',
                success: function (model) {
                    var pref = Ext.create(model, {
                        Name: CArABU.technicalservices.PortfolioCostApps.toolbox.getSnapshotPreferenceName(name),
                        Value: CArABU.technicalservices.PortfolioCostApps.toolbox.getEncodedSnapshotValueString(snapshotSettings, type)
                    });

                    pref.save({
                        callback: function (records, operation, success) {
                            if (success) {
                                console.log('prefs', records);
                                Ext.callback(this.onActionComplete, null, [this.records, []]);
                                var msg = Ext.String.format("Snapshot '{0}' saved successfully.", name);
                                Rally.ui.notify.Notifier.show({message: msg});
                            } else {
                                Rally.ui.notify.Notifier.showError({message: "Failed to save snapshots for " + name});
                                Ext.callback(this.onActionComplete, null, [[], this.records]);
                            }
                        },
                        scope: this
                    });
                },
                scope: this
            });

        }
    }
});
Ext.define("portfolio-cost-tracking-v2", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),

    mixins: [],

    printHeaderLabel: 'Portfolio Items',
    statePrefix: 'portfolio-tree',

    config: {
        defaultSettings: {
            piTypePickerConfig: {
                renderInGridHeader: true
            },
            selectedCalculationType: 'points',
            normalizedCostPerUnit: 1000,
            projectCostPerUnit: {},
            currencySign: '$',
            preliminaryBudgetField: 'PreliminaryEstimate'
        }
    },
    toggleState: 'grid',
    enableAddNew: false,
    enableGridBoardToggle: false,
    allowExpansionStateToBeSaved: false,
    plugins: ['rallygridboardappresizer'],
    actionMenuItems: [],
    enableImport: true,
    enableCsvExport: true,
    enablePrint: true,
    enableRanking: true,
    isWorkspaceScoped: false,
    modelNames: [],
    modelsContext: null,
    printHeaderLabel: '',
    statePrefix: null,

    items: [],

    portfolioItemRollupData: {},

    launch: function(){
        //todo: check for RPM?

        this.loadModelNames().then({
            success: function (modelNames) {
                this.modelNames = modelNames;
                if(!this.rendered) {
                    this.on('afterrender', this.loadGridBoard, this, {single: true});
                } else {
                    this.loadGridBoard();
                }
            },
            scope: this
        });
    },
    loadModelNames: function () {
        var promises = [this.fetchDoneStates(), this._createPITypePicker(),this.fetchProjectCostHistory()];
        return Deft.Promise.all(promises).then({
            success: function (results) {
                this.logger.log('results', results);
                this.currentType = results[1];
                this._initializeSettings(this.getSettings(), results[0], this.piTypePicker, results[2]);
                this._initializeRollupData(this.currentType.get('TypePath'));
                return [this.currentType.get('TypePath')];
            },
            scope: this
        });
    },
    fetchProjectCostHistory: function(){
        this.logger.log('fetchProjectCostHistory');
        var deferred = Ext.create('Deft.Deferred'),
            me=this;

        CArABU.technicalservices.ProjectCostModelBuilder.build('Preference', 'ProjectCostModel').then({
            success: function(model){
                Ext.create('Rally.data.wsapi.Store',{
                    model: model,
                    fetch: ['Name','Project','Type','Value','CreationDate'],
                    filters: [{
                        property: 'Name',
                        operator: "contains",
                        value: CArABU.technicalservices.ProjectCostModelBuilder.prefPrefix
                    },{
                        property: 'Workspace',
                        value: this.getContext().getWorkspace()._ref
                    }],
                    context: {
                        workspace: this.getContext().getWorkspace()._ref,
                        project: null
                    }
                }).load({
                    callback: function(records, operation, success){
                        me.logger.log('fetchProjectCostHistory', records, operation, success);
                        if (success){
                            deferred.resolve(records);
                        } else {
                            deferred.reject("Error loading project cost history: " + operation.error && operation.error.errors.join(','));
                        }
                    }
                });
            },
            scope: this
        });
        return deferred;
    },
    loadGridBoard: function () {
        this.logger.log('loadGridBoard', this.modelNames);

        this._getTreeGridStore().then({
            success: function (store) {
                this.addGridBoard(store);
            },
            scope: this
        });
    },

    addGridBoard: function (store) {
        if (this.gridboard) {
            this.gridboard.destroy();
        }

        var customColumns = this.getDerivedColumns() || [],
            columnCfgs = Ext.Array.merge(this.getColumnCfgs() || [], customColumns);
        this.logger.log('addGridBoard', store, this.modelNames, columnCfgs);

        this.gridboard = this.add({
            itemId: 'gridboard',
            xtype: 'rallygridboard',
            context: this.getContext(),
            toggleState: 'grid',
            modelNames: _.clone(this.modelNames),
            plugins: this.getGridBoardPlugins(),
            gridConfig: {
                columnCfgs: columnCfgs,
                derivedColumns: customColumns,
                store: store,
                bulkEditConfig: {
                    items: [{
                        xtype: 'snapshotbulkmenuitem'
                    }]
                },
                listeners: {
                    beforerender: function(g){
                        Ext.Array.each(g.columns, function(c){
                            if (c.flex > 10){
                                //The flex was set by the width before this.
                                c.width = c.flex;
                                delete c.flex;
                            }
                        });
                    }
                }
            },
            sharedViewAdditionalCmps: [this.piTypePicker],
            listeners: {
                viewchange: function(gb, view){
                    console.log('view',view,this.piTypePicker && this.piTypePicker.getValue());
                    if (this.piTypePicker && view && this.piTypePicker.getValue() !== view.piTypePicker){
                        this.piTypePicker.setValue(view.piTypePicker);
                        this._onTypeChange(this.piTypePicker);
                    } else {
                        this.loadGridBoard();
                    }

                },
                scope: this
            },
            height: this.getHeight()
        });

        this.fireEvent('gridboardadded', this.gridboard);
    },
    /**
     * We need to override this to show the picker in the grid header and also save state
     * rather than as a configuration
     */
    getGridBoardPlugins: function () {
        var plugins = [{
                ptype: 'rallygridboardinlinefiltercontrol',
                inlineFilterButtonConfig: {
                    modelNames: this.modelNames,
                    stateful: true,
                    stateId: this.getContext().getScopedStateId('pc-filter'),
                    inlineFilterPanelConfig: {
                        collapsed: false,
                        quickFilterPanelConfig: {
                            fieldNames: ['Owner', 'ScheduleState'],
                            addQuickFilterConfig: {
                                whiteListFields: ['Milestones', 'Tags']
                            }
                        },
                        advancedFilterPanelConfig: {
                            advancedFilterRowsConfig: {
                                propertyFieldConfig: {
                                    whiteListFields: ['Milestones', 'Tags']
                                }
                            }
                        }                                          
                    }
                }
        }];

        plugins.push({
            ptype: 'rallygridboardfieldpicker',
            headerPosition: 'left',
            modelNames: this.modelNames,
            stateful: true,
            stateId: this.getContext().getScopedStateId('field-picker')
        });


        plugins.push({
            ptype: 'rallygridboardsharedviewcontrol',
            stateful: true,
            stateId: this.getContext().getScopedStateId('pc-shared-view'),
            stateEvents: ['select','beforedestroy'],
            margin: 10

        });

        plugins = plugins.concat(this.getActionsMenuConfig() || []);
        return plugins;
    },
    getActionsMenuConfig: function () {
        var importItems = this._getImportItems();
        var printItems = this._getPrintItems();
        var exportItems = this._getExportItems();

        var tooltipTypes = []
            .concat(importItems.length ? 'Import' : [])
            .concat(exportItems.length ? 'Export' : [])
            .concat(printItems.length ? 'Print' : []);

        var menuItems = this.actionMenuItems.concat(importItems, exportItems, printItems);

        return tooltipTypes.length === 0 || this.toggleState === 'board' ? [] : [{
            ptype: 'rallygridboardactionsmenu',
            menuItems: menuItems,
            buttonConfig: {
                hidden: this.toggleState !== 'grid',
                iconCls: 'icon-export',
                toolTipConfig: {
                    html: tooltipTypes.join('/'),
                    anchor: 'top',
                    hideDelay: 0
                }
            }
        }];
    },
    _createPITypePicker: function () {
        if (this.piTypePicker && this.piTypePicker.destroy) {
            this.piTypePicker.destroy();
        }
        if (!this.down('#selector_box')){
            this.add({
                itemId: 'selector_box',
                layout: 'hbox',
                style: {
                    border: 0
                }
            });
        }
        this.down('#selector_box').removeAll();

        var deferred = new Deft.Deferred();

        this.piTypePicker = this.down('#selector_box').add({
            xtype: 'rallyportfolioitemtypecombobox',
            context: this.getContext(),
            labelAlign: 'right',
            labelWidth: 100,
            listeners: {
                select: this._onTypeChange,
                ready: {
                    fn: function (picker) {
                        var newType = picker && picker.getRecord();
                        deferred.resolve(newType);
                    },
                    single: true
                },
                scope: this
            }
        });

        return deferred.promise;
    },
    _initializeRollupData: function(newType){
        this.logger.log('_initializeRollupData', newType);
        if (this.rollupData){
            this.rollupData.destroy();
        }

        this.rollupData = Ext.create('CArABU.technicalservices.RollupCalculator', {
            portfolioItemType: newType
        });
    },
    _initializePortfolioItemTypes: function(cb){

        var items = cb.getStore().data.items,
            portfolioItemTypes = new Array(items.length);

        Ext.Array.each(items, function(item){
            var idx = Number(item.get('Ordinal'));
            portfolioItemTypes[idx] = { typePath: item.get('TypePath'), name: item.get('Name'), ordinal: idx };
        });
        CArABU.technicalservices.PortfolioItemCostTrackingSettings.portfolioItemTypes = portfolioItemTypes;
    },
    _onTypeChange: function (picker, records) {
        var newType = picker && picker.getRecord();
        this.logger.log('_onTypeChange', picker, newType);

        if (newType && this.currentType && newType.get('_ref') !== this.currentType.get('_ref')) {
            this.currentType = newType;
            this.modelNames = [newType.get('TypePath')];
            this._initializeRollupData(newType.get('TypePath'));
            this.loadGridBoard();
        }
    },
    _initializeSettings: function(settings, doneScheduleStates, piTypePicker, projectCostHistory){

        CArABU.technicalservices.PortfolioItemCostTrackingSettings.notAvailableText = "--";
        CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencySign = settings.currencySign;
        CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencyPrecision = 0;
        CArABU.technicalservices.PortfolioItemCostTrackingSettings.currencyEnd = false;
        if (doneScheduleStates){
            CArABU.technicalservices.PortfolioItemCostTrackingSettings.completedScheduleStates = doneScheduleStates;
        }
        CArABU.technicalservices.PortfolioItemCostTrackingSettings.normalizedCostPerUnit = settings.normalizedCostPerUnit;

        CArABU.technicalservices.PortfolioItemCostTrackingSettings.setProjectCostHistory(projectCostHistory);

        CArABU.technicalservices.PortfolioItemCostTrackingSettings.preliminaryBudgetField = settings.preliminaryBudgetField;

        CArABU.technicalservices.PortfolioItemCostTrackingSettings.setCalculationType(settings.selectedCalculationType);

        this._initializePortfolioItemTypes(piTypePicker);

    },
    _showExportMenu: function () {
        //var columnCfgs = this.down('rallytreegrid').columnCfgs,
        var columnCfgs = this.down('rallytreegrid').headerCt.getGridColumns(),
            additionalFields = _.filter(columnCfgs, function(c){ return (c.xtype === 'rallyfieldcolumn' && c.text != "Rank"); }),
            costFields = this.getDerivedColumns(),
            columns = Ext.Array.merge(additionalFields, costFields);
        
        additionalFields = _.pluck(additionalFields, 'dataIndex');

        var filters = this.down('rallygridboard').currentCustomFilter.filters || [],
            fetch = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getTreeFetch(additionalFields),
            root_model = this.currentType.get('TypePath');

        var exporter = new CArABU.technicalservices.Exporter();
        exporter.on('statusupdate', this._showStatus, this);

        this.logger.log('columns:', columns);
        
        exporter.fetchExportData(root_model,filters,fetch,columns).then({
            scope: this,
            success: function(csv){
                var filename = Ext.String.format("export-{0}.csv",Ext.Date.format(new Date(),"Y-m-d-h-i-s"));
                exporter.saveCSVToFile(csv, filename);
            },
            failure: function(msg){
                Rally.ui.notify.Notifier.showError({message: "An error occurred fetching the data to export:  " + msg});
            }
        });
    },
    _loadRollupData: function(records){
        this.logger.log('_loadRollupData', records);

        var loader = Ext.create('CArABU.technicalservices.RollupDataLoader',{
            context: this.getContext(),
            portfolioItemTypes: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getPortfolioItemTypes(),
            featureName: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getFeatureName(),
            listeners: {
                rollupdataloaded: function(portfolioHash, defects){
                    this._processRollupData(portfolioHash,defects,records);
                },
                loaderror: this._handleLoadError,
                statusupdate: this._showStatus,
                scope: this
            }
        });
        loader.loadDescendants(records);
    },
    _handleLoadError: function(msg){
        Rally.ui.notify.Notifier.showError({message: msg});
    },
    _processRollupData: function(portfolioHash, defects, records){
        this.logger.log('_processRollupData');
        var me = this;
        portfolioHash[records[0].get('_type').toLowerCase()] = records;
        this.rollupData.addRollupRecords(portfolioHash, defects);
        this.rollupData.updateModels(records);
        me._showStatus(null);
    },
    _showStatus: function(message){
        if (message) {
            Rally.ui.notify.Notifier.showStatus({
                message: message,
                showForever: true,
                closable: false,
                animateShowHide: false
            });
        } else {
            Rally.ui.notify.Notifier.hide();
        }

        this.down('rallygridboard').getGridOrBoard().updateLayout(); //getView().refresh();
    },
    _getExportItems: function() {
        return [{
            text: 'Export to CSV...',
            handler: this._showExportMenu,
            scope: this
        }];
    },
    _getImportItems: function(){
        return [];
    },
    _getPrintItems: function(){
        return [];
    },
    _getTreeGridStore: function () {

        var fetch = CArABU.technicalservices.PortfolioItemCostTrackingSettings.getTreeFetch([]);
        this.logger.log('_getTreeGridStore', fetch)

        return Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            //childPageSizeEnabled: true,
            context: this.getContext().getDataContext(),
            enableHierarchy: true,
            fetch: fetch,
            models: this.modelNames, // _.clone(this.models),
            //pageSize: 25,
            remoteSort: true,
            root: {expanded: true}
        }).then({
            success: function (treeGridStore) {
                treeGridStore.model.addField({name: '_rollupData', type: 'auto', defaultValue: null, getUUID: function() { return "_rollupData"; }});
                treeGridStore.on('load', this.updateDerivedColumns, this);
                return treeGridStore;
            },
            scope: this
        });
    },
    updateDerivedColumns: function(store, node, records){
        this.logger.log('updateDerivedColumns');
        if (!store.model.getField('_rollupData')){
            store.model.addField({name: '_rollupData', type: 'auto', defaultValue: null});
        }

        var unloadedRecords = this.rollupData.updateModels(records);

        if (unloadedRecords && unloadedRecords.length > 0 && node.parentNode === null){
            this._loadRollupData(unloadedRecords);
        }
    },
    getDerivedColumns: function(){

        return [{
            text: "Actual CapEx Cost To Date",
            xtype: 'costtemplatecolumn',
            dataIndex: '_rollupData',
            costField: '_rollupDataActualCost',
            sortable: false,
            flex: 1,
            tooltip: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getHeaderTooltip('_rollupDataActualCost')
        },{
            text: "Remaining CapEx Cost",
            xtype: 'costtemplatecolumn',
            dataIndex: '_rollupData',
            sortable: false,
            costField: '_rollupDataRemainingCost',
            flex: 1,
            tooltip: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getHeaderTooltip('_rollupDataRemainingCost')
        },{
            text: "Actual OpEx Cost To Date",
            xtype: 'costtemplatecolumn',
            dataIndex: '_rollupData',
            costField: '_rollupDataActualOpExCost',
            sortable: false,
            flex: 1,
            tooltip: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getHeaderTooltip('_rollupDataActualCost')
        },{
            text: "Remaining OpEx Cost",
            xtype: 'costtemplatecolumn',
            dataIndex: '_rollupData',
            sortable: false,
            costField: '_rollupDataRemainingOpExCost',
            flex: 1,
            tooltip: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getHeaderTooltip('_rollupDataRemainingCost')
        },{
            text: 'Total Projected',
            xtype: 'costtemplatecolumn',
            dataIndex: '_rollupData',
            sortable: false,
            costField: '_rollupDataTotalCost',
            flex: 1,
            tooltip: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getHeaderTooltip('_rollupDataTotalCost')
        },{
            text: 'Preliminary Budget',
            xtype: 'costtemplatecolumn',
            dataIndex: '_rollupData',
            sortable: false,
            costField: '_rollupDataPreliminaryBudget',
            flex: 1,
            tooltip: CArABU.technicalservices.PortfolioItemCostTrackingSettings.getHeaderTooltip('_rollupDataPreliminaryBudget')
        }];
    },
    getColumnCfgs: function(){

        return  [{
            dataIndex: 'Name',
            text: 'Name'
        },{
            dataIndex: 'Project',
            text: 'Project',
            editor: false
        },{
            dataIndex: 'LeafStoryPlanEstimateTotal',
            text: 'Plan Estimate Total'
        }, {
            dataIndex: 'PercentDoneByStoryPlanEstimate',
            text: '% Done by Story Points'
        }];
    },
    getSettingsFields: function() {
        return CArABU.technicalservices.PortfolioItemCostTrackingSettings.getFields(this.getSettings());
    },
    onSettingsUpdate: function(settings){

        this._initializeSettings(settings,null,this.piTypePicker);
        this._initializeRollupData(this.currentType.get('TypePath'));
        this.loadGridBoard();
    },
    onDestroy: function() {
        this.callParent(arguments);
        if (this.rollupData){
            delete this.rollupData;
        }
    },
    fetchDoneStates: function(){
        var deferred = Ext.create('Deft.Deferred');

        Rally.data.ModelFactory.getModel({
            type: 'HierarchicalRequirement',
            success: function(model) {
                var field = model.getField('ScheduleState');
                field.getAllowedValueStore().load({
                    callback: function(records, operation, success) {

                        if (success){
                            var values = [];
                            for (var i=records.length - 1; i > 0; i--){
                                values.push(records[i].get('StringValue'));
                                if (records[i].get('StringValue') === "Accepted"){
                                    i = 0;
                                }
                            }
                            deferred.resolve(values);
                        } else {
                            deferred.reject('Error loading ScheduleState values for User Story:  ' + operation.error.errors.join(','));
                        }
                    },
                    scope: this
                });
            },
            failure: function() {
                var error = "Could not load schedule states";
                deferred.reject(error);
            }
        });
        return deferred.promise;
    }
});

            
               Rally.launchApp('portfolio-cost-tracking-v2', {
                   name: 'Portfolio Cost Tracking (v2)'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.lbl {

    text-transform: uppercase;
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 10px;
}

.x-form-trigger-wrap {
    margin-top: 0px!important;
}

.x-column-header-text {
    margin-right: 0px!important;
}
.x-box-inner {
    overflow: visible;
}

p {
    color:#FAD200;
}
    </style>

</head>
<body></body>
</html>